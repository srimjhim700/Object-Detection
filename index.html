<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Interaction App</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .controls,
        .io-areas {
            display: flex;
            gap: 10px;
            align-items: center;
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .io-areas {
            flex-direction: column;
            align-items: stretch;
        }

        textarea {
            width: 300px;
            height: 80px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        #videoFeed {
            width: 480px;
            height: 360px;
            border: 2px solid #333;
            background-color: #000;
            border-radius: 8px;
        }

        #startButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            color: white;
        }

        #startButton.start {
            background-color: #28a745;
            /* Green */
        }

        #startButton.stop {
            background-color: #dc3545;
            /* Red */
        }

        label {
            font-weight: bold;
        }

        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body>

    <h1>Camera Interaction App</h1>

    <video id="videoFeed" autoplay playsinline></video>
    <canvas id="canvas" class="hidden"></canvas> <!-- For capturing frames -->

    <div class="io-areas">
        <div>
            <label for="baseURL">Base API:</label><br>
            <input id="baseURL" name="Instruction" value="http://localhost:8080"></textarea>
        </div>
        <div>
            <label for="instructionText">Instruction:</label><br>
            <textarea id="instructionText" style="height: 2em; width: 40em" name="Instruction"></textarea>
            <button id="voiceButton">ðŸŽ¤ Speak Instruction </button>
        </div>
        <div>
            <label for="responseText">Response:</label><br>
            <textarea id="responseText" style="height: 2em; width: 40em" name="Response" readonly
                placeholder="Server response will appear here..."></textarea>
        </div>
    </div>

    <div class="controls">
        <label for="intervalSelect">Interval between 2 requests:</label>
        <select id="intervalSelect" name="Interval between 2 requests">
            <option value="100">100ms</option>
            <option value="250">250ms</option>
            <option value="500" selected>500ms</option>
            <option value="1000">1s</option>
            <option value="2000">2s</option>
        </select>
        <button id="startButton" class="start">Start</button>

    </div>

    <script>
        const video = document.getElementById('videoFeed');
        const canvas = document.getElementById('canvas');
        const baseURL = document.getElementById('baseURL');
        const instructionText = document.getElementById('instructionText');
        const responseText = document.getElementById('responseText');
        const intervalSelect = document.getElementById('intervalSelect');
        const startButton = document.getElementById('startButton');

        // instructionText.value = "What do you see?"; // default instruction
        // instructionText.value = transcript;
        // instructionText.blur();
        // instructionText.focus();

        let stream;
        let intervalId;
        let isProcessing = false;

        // voice command-------------
        const voiceButton = document.getElementById('voiceButton');
        let recognition;

        // if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
        //     const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        //     recognition = new SpeechRecognition();
        //     recognition.lang = 'en-US'; // Set language as needed
        //     recognition.interimResults = true;
        //     recognition.maxAlternatives = 1;

        //     recognition.onstart = () => {
        //         voiceButton.textContent = "Listening...";
        //     };
        //     recognition.onend = () => {
        //         voiceButton.textContent = "ðŸŽ¤ Speak Instruction";
        //     };
        //     recognition.onresult = (event) => {
        //         const transcript = event.results[0][0].transcript;
        //         instructionText.value = transcript;
        //     };

        //     voiceButton.addEventListener('click', () => {
        //         recognition.start();
        //         // recognition.addEventListener('result', e() => {
        //         //     const transcript = Array.from(e.results)
        //         //     .map(result = result[0])
        //         //     .map(result = result.transcript),
        //         //     instructionText.innerHTML = transcript;

        //         // })
        //     });
        // } else {
        //     voiceButton.disabled = true;
        //     voiceButton.textContent = "Voice not supported";
        // } // finish---------------

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        if (!SpeechRecognition) {
            console.error('[SpeechRecognition] Error: SpeechRecognition API is NOT supported in this browser.');
        } else {
            const recognition = new SpeechRecognition();

            recognition.lang = 'en-US';
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            console.log('[SpeechRecognition] Configuration:');
            console.log('  language:', recognition.lang);
            console.log('  interimResults:', recognition.interimResults);
            console.log('  maxAlternatives:', recognition.maxAlternatives);

            // Check microphone permission state (if supported)
            if (navigator.permissions) {
                navigator.permissions.query({ name: 'microphone' })
                .then(permissionStatus => {
                    console.log('[Permissions API] Microphone permission state:', permissionStatus.state);
                    permissionStatus.onchange = () => {
                    console.log('[Permissions API] Microphone permission state changed to:', permissionStatus.state);
                    };
                })
                .catch(err => {
                    console.warn('[Permissions API] Could not query microphone permissions:', err);
                });
            } else {
                console.warn('[Permissions API] Not supported in this browser.');
            }

            recognition.onstart = () => {
                instructionText.value = "Listening"; 
                console.log('[SpeechRecognition] Status: Listening started.');
            };

            recognition.onaudiostart = () => {
                console.log('[SpeechRecognition] Event: Audio capturing started.');
            };

            recognition.onaudioend = () => {
                console.log('[SpeechRecognition] Event: Audio capturing ended.');
            };

            recognition.onspeechstart = () => {
                console.log('[SpeechRecognition] Event: Speech detected.');
            };

            recognition.onspeechend = () => {
                console.log('[SpeechRecognition] Event: Speech ended.');
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                const confidence = event.results[0][0].confidence;
                console.log(`[SpeechRecognition] Result: "${transcript}" (Confidence: ${(confidence * 100).toFixed(2)}%)`);
                instructionText.value = transcript;
                instructionText.innerText = transcript;
            };


            recognition.onerror = (event) => {
                console.error(`[SpeechRecognition] Error occurred: ${event.error}`);
                if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    console.error(`[SpeechRecognition] Microphone access was denied by the user.`);
                }
            };

            recognition.onend = () => {
                console.log('[SpeechRecognition] Status: Recognition ended.');
            };

            voiceButton.addEventListener('click', () => {
                try {
                    recognition.start();
                } catch (error) {
                    console.error('[SpeechRecognition] Failed to start recognition:', error);
                }
            });



            // Returns response text (string)
            async function sendChatCompletionRequest(instruction, imageBase64URL) {
                const response = await fetch(`${baseURL.value}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        max_tokens: 100,
                        messages: [
                            {
                                role: 'user', content: [
                                    { type: 'text', text: instruction },
                                    {
                                        type: 'image_url', image_url: {
                                            url: imageBase64URL,
                                        }
                                    }
                                ]
                            },
                        ]
                    })
                });
                if (!response.ok) {
                    const errorData = await response.text();
                    return `Server error: ${response.status} - ${errorData}`;
                }
                const data = await response.json();
                return data.choices[0].message.content;
            }

            // 1. Ask for camera permission on load
            async function initCamera() {
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                    video.srcObject = stream;
                    responseText.value = "Camera access granted. Ready to start.";
                } catch (err) {
                    console.error("Error accessing camera:", err);
                    responseText.value = `Error accessing camera: ${err.name} - ${err.message}. Please ensure permissions are granted and you are on HTTPS or localhost.`;
                    alert(`Error accessing camera: ${err.name}. Make sure you've granted permission and are on HTTPS or localhost.`);
                }
            }

            function captureImage() {
                if (!stream || !video.videoWidth) {
                    console.warn("Video stream not ready for capture.");
                    return null;
                }
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                return canvas.toDataURL('image/jpeg', 0.8); // Use JPEG for smaller size, 0.8 quality
            }

            async function sendData() {
                if (!isProcessing) return; // Ensure we don't have overlapping requests if processing takes longer than interval

                const instruction = instructionText.value;
                const imageBase64URL = captureImage();

                if (!imageBase64URL) {
                    responseText.value = "Failed to capture image. Stream might not be active.";
                    // Optionally stop processing if image capture fails consistently
                    // handleStop();
                    return;
                }

                const payload = {
                    instruction: instruction,
                    imageBase64URL: imageBase64URL
                };

                try {
                    const response = await sendChatCompletionRequest(payload.instruction, payload.imageBase64URL);
                    if (isProcessing){
                        
                        responseText.value = response;
                    }
                } catch (error) {
                    console.error('Error sending data:', error);
                    responseText.value = `Error: ${error.message}`;
                }
            }

            function handleStart() {
                if (!stream) {
                    responseText.value = "Camera not available. Cannot start.";
                    alert("Camera not available. Please grant permission first.");
                    return;
                }
                isProcessing = true;
                startButton.textContent = "Stop";
                startButton.classList.remove('start');
                startButton.classList.add('stop');

                instructionText.disabled = true;
                intervalSelect.disabled = true;

                responseText.value = "Processing started...";

                const intervalMs = parseInt(intervalSelect.value, 10);

                // Initial immediate call
                sendData();

                // Then set interval
                intervalId = setInterval(sendData, intervalMs);
            }

            function handleStop() {
                isProcessing = false;
                if (intervalId) {
                    clearInterval(intervalId);
                    intervalId = null;
                }
                startButton.textContent = "Start";
                startButton.classList.remove('stop');
                startButton.classList.add('start');

                instructionText.disabled = false;
                intervalSelect.disabled = false;
 
                responseText.value = "Processing stopped.";
                
            }

            // function handleStop() {
            //     isProcessing = false;
            //     if (intervalId) {
            //         clearInterval(intervalId);
            //         intervalId = null;
            //     }
            //     startButton.textContent = "Start";
            //     startButton.classList.remove('stop');
            //     startButton.classList.add('start');

            //     instructionText.disabled = false;
            //     intervalSelect.disabled = false;
            //     if (responseText.value.startsWith("Processing started...")) {
            //         responseText.value = "Processing stopped.";
            //     }

            //     // --- Add this block to stop the camera stream instantly ---
            //     if (stream) {
            //         stream.getTracks().forEach(track => track.stop()); // Stop all tracks (video, audio)
            //         video.srcObject = null; // Remove the stream from the video element
            //         stream = null;
            //     }
            // }



            startButton.addEventListener('click', () => {
                if (isProcessing) {
                    handleStop();
                } else {
                    handleStart();
                }
            });

            // Initialize camera when the page loads
            window.addEventListener('DOMContentLoaded', initCamera);

            // Optional: Stop stream when page is closed/navigated away to release camera
            window.addEventListener('beforeunload', () => {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                if (intervalId) {
                    clearInterval(intervalId);
                }
            });
        }
    </script>
</body>

</html>